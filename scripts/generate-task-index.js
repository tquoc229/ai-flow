#!/usr/bin/env node

/**
 * Generate Task Index Files from Task Detail Files
 *
 * This script reads all task detail files and generates the corresponding
 * tasks.md index files. This ensures single source of truth - status is
 * maintained only in task files, index is auto-generated.
 *
 * Usage:
 *   node scripts/generate-task-index.js
 *
 * Called by:
 *   - Pre-commit hook (.git/hooks/pre-commit)
 *   - Manual execution when needed
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

// Color output for terminal
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

/**
 * Extract front matter and status from task markdown file
 */
function parseTaskFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');

    // Extract task ID and name from first heading
    const headingMatch = content.match(/^#\s+(.+)$/m);
    const heading = headingMatch ? headingMatch[1] : 'Unknown Task';

    // Extract task ID from heading (format: "Task-ID Task-Name" or "[Task-ID] Task-Name")
    const taskIdMatch = heading.match(/^[\[\s]*(\d+-\d+)[\]\s:]*/);
    const taskId = taskIdMatch ? taskIdMatch[1] : path.basename(filePath, '.md');

    // Extract task name (after task ID)
    const taskName = taskIdMatch
      ? heading.replace(taskIdMatch[0], '').trim()
      : heading;

    // Find status in markdown (look for "**Status:** X" or "Status: X")
    const statusMatch = content.match(/\*\*Status:\*\*\s*`?(\w+)`?/i) ||
                       content.match(/Status:\s*`?(\w+)`?/i);
    const status = statusMatch ? statusMatch[1] : 'Unknown';

    // Extract description (first paragraph after heading)
    const descMatch = content.match(/^#.+\n\n(.+?)(?:\n\n|\n##)/s);
    const description = descMatch
      ? descMatch[1].trim().substring(0, 100) + (descMatch[1].length > 100 ? '...' : '')
      : '';

    return {
      taskId,
      taskName,
      status,
      description,
      filePath: path.basename(filePath),
    };
  } catch (error) {
    log(`Error parsing ${filePath}: ${error.message}`, 'yellow');
    return null;
  }
}

/**
 * Generate tasks.md index file content
 */
function generateTaskIndex(pbiId, tasks) {
  const lines = [];

  // Header
  lines.push(`# Tasks for PBI ${pbiId}`);
  lines.push('');
  lines.push('> **Note:** This file is AUTO-GENERATED from task files.');
  lines.push('> Do not edit manually - changes will be overwritten.');
  lines.push('> Update status in individual task files instead.');
  lines.push('');

  // Link back to PBI
  lines.push(`**Parent PBI:** [PBI ${pbiId}: View Details](prd.md)`);
  lines.push('');

  // Task table
  lines.push('## Task Summary');
  lines.push('');
  lines.push('| Task ID | Name | Status | Description |');
  lines.push('| :------ | :--- | :----- | :---------- |');

  // Sort tasks by task ID
  const sortedTasks = tasks.sort((a, b) => {
    const [aPbi, aNum] = a.taskId.split('-').map(Number);
    const [bPbi, bNum] = b.taskId.split('-').map(Number);
    return aNum - bNum;
  });

  // Add task rows
  for (const task of sortedTasks) {
    const nameLink = `[${task.taskName}](${task.filePath})`;
    const statusBadge = `\`${task.status}\``;
    const desc = task.description || '-';

    lines.push(`| ${task.taskId} | ${nameLink} | ${statusBadge} | ${desc} |`);
  }

  lines.push('');

  // Column definitions
  lines.push('**Column Definitions:**');
  lines.push('- **Task ID**: Unique identifier in format `<PBI-ID>-<TaskNum>`');
  lines.push('- **Name**: Task name with link to detail file');
  lines.push('- **Status**: Current status (Proposed, Agreed, InProgress, Review, Done, Blocked)');
  lines.push('- **Description**: Brief summary of task objective');
  lines.push('');

  // Status summary
  const statusCounts = {};
  for (const task of tasks) {
    statusCounts[task.status] = (statusCounts[task.status] || 0) + 1;
  }

  lines.push('## Status Summary');
  lines.push('');
  for (const [status, count] of Object.entries(statusCounts).sort()) {
    lines.push(`- **${status}**: ${count} task${count > 1 ? 's' : ''}`);
  }
  lines.push('');

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Auto-generated by `scripts/generate-task-index.js`*');
  lines.push('');

  return lines.join('\n');
}

/**
 * Main execution
 */
function main() {
  log('üìù Generating task index files...', 'blue');

  // Find all PBI directories
  const deliveryPath = path.join(process.cwd(), 'docs', 'delivery');

  if (!fs.existsSync(deliveryPath)) {
    log('‚ö†Ô∏è  No docs/delivery directory found. Skipping task index generation.', 'yellow');
    return;
  }

  const pbiDirs = fs.readdirSync(deliveryPath)
    .filter(name => fs.statSync(path.join(deliveryPath, name)).isDirectory())
    .filter(name => /^\d+$/.test(name)); // Only numeric directories (PBI IDs)

  if (pbiDirs.length === 0) {
    log('‚ÑπÔ∏è  No PBI directories found.', 'blue');
    return;
  }

  let totalGenerated = 0;

  for (const pbiId of pbiDirs) {
    const pbiPath = path.join(deliveryPath, pbiId);
    const indexPath = path.join(pbiPath, 'tasks.md');

    // Find all task files in this PBI directory
    const taskFiles = glob.sync(path.join(pbiPath, `${pbiId}-*.md`));

    if (taskFiles.length === 0) {
      log(`  PBI ${pbiId}: No task files found, skipping`, 'yellow');
      continue;
    }

    // Parse all task files
    const tasks = taskFiles
      .map(parseTaskFile)
      .filter(task => task !== null);

    if (tasks.length === 0) {
      log(`  PBI ${pbiId}: No valid tasks parsed, skipping`, 'yellow');
      continue;
    }

    // Generate index content
    const indexContent = generateTaskIndex(pbiId, tasks);

    // Write index file
    fs.writeFileSync(indexPath, indexContent, 'utf8');

    log(`  ‚úì Generated tasks.md for PBI ${pbiId} (${tasks.length} tasks)`, 'green');
    totalGenerated++;
  }

  if (totalGenerated > 0) {
    log(`\n‚úÖ Successfully generated ${totalGenerated} task index file(s)`, 'green');
  } else {
    log('\n‚ÑπÔ∏è  No task index files generated', 'blue');
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { parseTaskFile, generateTaskIndex };
